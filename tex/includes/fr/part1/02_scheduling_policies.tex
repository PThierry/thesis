%%
%%
%% scheduling_policies.tex for thesis in /doctorat/these/tex
%%
%% Made by Philippe THIERRY
%% Login   <Philippe THIERRYreseau-libre.net>
%%
%% Started on  Fri Mar 12 16:28:03 2010 Philippe THIERRY
%% Last update Thu Jul 15 15:56:53 2010 Philippe THIERRY
%%

\chapter{Les familles d'ordonnanceurs temps réel}
\doMinitoc

\paragraph{}
Les différents ordonnanceurs temps réel possèdent plusieurs propriétés quant à la gestion des taches.
Ce chapitre définit séparément chaque propriété, construisant ainsi un ensemble homogène. Chaque
ordonnanceur se situe à l'intersection des ensembles décrivant toutes ses propriétés.

\section{Par dynamique d'ordonnancement}

\subsection{L'ordonnancement en ligne}

\paragraph{}
Les choix d'ordonnancement se font durant l'exécution, en fonction de l'état du système (nombre de taches,
priorités, durée d'exécution).

\subsection{L'ordonnancement hors ligne}

\paragraph{}
La politique d'ordonnancement est définie par avance. Elle est donc optimisée pour un cas particulier de jeu
de taches ({\it taskset}), mais pose problème en cas d'impact non prévu sur la dynamique d'exécution (effets de caches, de surcharge
de bus, WCET trop grand ou trop faible, etc).

\section{Par schéma d'exécution}

\paragraph{}
Le schéma suivant décrit l'automate générique caractérisant les différents états d'une tache :
\begin{figure}[h]
\input{figures/sched_graph.tex}
\caption{schéma générique de la dynamique d'ordonnancement}
\end{figure}

\subsection{Les ordonnanceurs préemptifs}

\paragraph{}
Les taches sont préemptées à une période prédéfinie, fixe ou dynamique, nommée {\it \index{quantum}quantum}.  En conséquence,
une tache s'exécute en plusieurs fois. Cela implique que l'ordonnanceur s'exécute plus souvent que
dans le cadre du mode non préemptif. La plupart du temps, l'ordonnanceur est de type {\it \index{time-driven}time-driven} (il s'appuie
sur une horloge pour régler sa période d'éxection). C'est le cas par exemple du Round-Robin, qui préempte les taches sur quantum.\\

\subsection{Les ordonnanceurs non préemptifs}

\paragraph{}
Une fois élue, chaque tache est exécutée dans son intégralité. Cela écarte les problématiques de rechargement
du cache lié à la préemption de tache, et les algorithmes d'ordonnancement ont l'avantage de la simplicité.\\
Cependant, il est plus difficile de garantir le {\it \index{WCET}\gls{wcet}} que dans le cadre du mode préemptif. Un ordonnancement en mode
FIFO s'exécute sans préemption, faisant s'exécuter les taches les unes à la suite des autres, dans l'ordre d'arrivée.

\paragraph{}
L'ordonnanceur peut également être de type {\it \index{event-driven}event-driven}, comme dans le cadre de préemption sur arrivée d'une tache
de priorité supérieure à celle en cours d'exécution. C'est le cas par exemple de l'EDF, qui ne préempte que sur l'arrivée d'une
tache plus prioritaire.

\subsection{Les ordonnanceurs mixtes}

\paragraph{}
Selon la priorité de la tache, cette dernière s'exécute sans préemption ou avec préemption.

\section{Par oisiveté}

\subsection{Les ordonnanceurs oisifs}

Les ordonnanceurs préem

\subsection{Les ordonnanceurs non oisif}

\section{Par politique de priorisation}

\subsection{Les ordonnanceurs à priorité fixe}

\paragraph{}
La priorité est associée à une tache au moment de sa création. Cette dernière est maintenue tout au long de la vie de cette
tache.

\subsection{Les ordonnanceurs à priorité dynamique}

\paragraph{}
La priorité de la tache varie, en fonction par exemple de son vieillissement et/ou de son historique de consommation CPU.
C'est le cas de la plupart des ordonnanceurs nom temps réels, comme SFQ (FIXME à confirmer)n ou encore SCHED\_OTHER (FIXME trouver
son vrai nom).

\subsection{Les ordonnanceurs à priorité hybride}

\paragraph{}
La priorité peut varier, selon le type de tache. On parle d'ordonnanceurs {\it FP/DP} ({\it Fixed Priority/Dynamic Priority}).

\section{Cas des ordonnanceurs SMP}

\paragraph{}
Les grandes familles d'ordonnanceurs SMP temps-réel sont les suivantes :\\
\begin{enumerate}
\item \index{Partitioned scheduling}Partitioned scheduling
\item \index{Global scheduling}Global scheduling
\item \index{Semi-partitioned scheduling}Semi-partitioned scheduling
\end{enumerate}

\subsection{Partitioned scheduling}

\paragraph{}
Il y a autant de queues de processus que de c{\oe}urs. La répartition des tâches se fait
statiquement. Cela pose cependant la problématique de l'impact des synchronisations et des locks (besoin de
précédance entre les tâches).

\subsection{Global scheduling}

\paragraph{}
Il y a une et une seule queue de processus pour l'ensemble des tâches. Cela pose le
problème d'accès en écriture à cette queue dans les différentes instanciations
de l'algorithme d'ordonnancement (une instance par c{\oe}ur \textit{actif}, afin
de maintenir une bonne optimisation du coût de l'euristique d'ordonnancement).

\subsection{Semi-partitioned scheduling}

\paragraph{}
Il en existe deux types :
\begin{itemize}
\item job partitioning
\item instance partitioning
\end{itemize}

\subsubsection{Job partitioning}

\paragraph{}
Une instance d'une tâche s'exécute complètement sur un seul c{\oe}ur. Par contre,
à chaque ré-exécution de la tâche, son positionnement dans les c{\oe}urs peut varier.
Cette variation est cependant fixée par avance et maîtrisée. Elle respecte donc un schéma
prédéfini et le ré-exécute indéfiniment.

\subsubsection{Instance partitioning}

\paragraph{}
Un processus en cours d'exécution peut migrer d'un c{\oe}ur à un autre.
Kato $(jap)$ propose l'algorithme suivant :
Le WCET de la tâche est découpé en blocs de taille $\frac{D_{i}}{s}$, où
$D_{i}$ est le temps avant lequel la tâche doit être exécutée, et $s$ le
nombre de c{\oe}urs \textit{actifs}.\\

\paragraph{}
À chaque fin de bloc, le processus migre d'un c{\oe}ur au suivant.
Cela a pour conséquence de consommer le moins de c{\oe}urs possible, tout
en les chargeant au maximum. C'est à double tranchant dans le sens où
toute variation des hypothèses (inexactitude de WCET, surcharge temporelle) impacte violemment
la capacité d'ordonnancement des tâches.\\


\paragraph{}
L'algorithme ne semble donc pas résistant à toute élasticité du WCET, même contrôlée.
Cette euristique ne possède pas de viabilité (\textit{sustainability} - capacité à résister à
l'élasticité de valeurs de $c_{i}$, $T_{i}$, ou $D_{i}$, quel que soit la t\^{a}che $\tau_{i}$).\\
Il s'agit d'une propriété importante du fait que la mesure du WCET
peut être trop pessimiste (mesure via pire cas du graphe d'exécution,
mais où le processus ne s'exécute que rarement en suivant cette branche) ou trop optimiste
(mesure au travers d'une étude empirique sur le comportement du processus, n'ayant pas
forcément pris en compte le véritable \textit{pire cas} si celui ci ne s'est pas produit).
