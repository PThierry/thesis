%%
%%
%% definitions_of_inputs.tex for thesis in /doctorat/these/tex
%%
%% Made by Philippe THIERRY
%% Login   <Philippe THIERRYreseau-libre.net>
%%
%% Started on  Fri Mar 12 16:23:03 2010 Philippe THIERRY
%% Last update Wed Jun 16 13:51:58 2010 Philippe THIERRY
%%

\chapter{DE LA MESURE ET DE L'EMPLOI DU WCET}


%\begin{changemargin}{1cm}{1cm}
{\it
Il existe deux types de système temps réel :
\begin{itemize}
\item Les systèmes temps réel durs, où les taches doivent possèdent une date limite de fin d'exécution
dont le dépassement a un impact fort sur le bon fonctionnement du système.
\item Les systèmes temps réel souples, où le dépassement de la date limite de fin d'exécution est acceptable.
à une qualité de service fournie par le système.
\end{itemize}
Dans les deux cas, il est nécessaire d'évaluer une métrique : la durée d'exécution pire cas d'une tache.
}
%\end{changemargin}
\doMinitoc

\section{Définitions préliminaires}

\subsection{Définition du temps réel}

\paragraph{}
Comme le montre le schéma \ref{fig:rt_hard_soft}, il existe trois grandes familles de taches :
\begin{itemize}
\item Les taches temps réel dur, comme la tache {\it A}. Elles doivent respecter scrupuleusement un
temps maximum d'exécution, faute de quoi l'utilisabilité des résultats de la tache est nulle.
\item Les taches temps réel souple, comme la tache {\it B}. L'utilisabilité des résultats de la tache décroit avec son retard.
\item Les taches non temps réel. Il n'est pas définit de temps maximum d'exécution. L'utilisabilité des reésultats
reste constante.
\end{itemize}

\begin{figure}[h]
\input{figures/rt_hard_soft.tex}
\label{fig:rt_hard_soft}
\caption{Les trois grandes familles de taches}
\end{figure}


\subsection{Définition du WCET}

\paragraph{}
Le \gls{wcet} ({\it Worst Case Execution Time}) définit la durée d'exécution maximum d'une tache. Associée à une {\it deadline},
elle permet, pour une liste de taches donnée :
\begin{itemize}
\item de connaître à l'avance si cette liste est ordonnançable ou si certaines taches ne pourront pas
être terminées à temps.
\item de définir une répartition temporelle des taches pour respecter la {\it deadline} de chacune.
\end{itemize}

\paragraph{}
Sont définies les valeurs $R_{i}$, $D_{i}$ et $U_{i}$, avec les propriétés définies dans les équations FIXME:

\begin{eqnarray}
\forall i, R_{i} \le D_{i}\\
\forall i, R_{i} \ge C_{i}\\
\label{eqn:Ri}
U_{i}, \displaystyle{\sum_{i \in [1, n]}} U_{i} \le 1
\label{eqn:Ui}
\end{eqnarray}


$\Delta T$ est la marge que possède l'ordonnanceur entre le coût d'exécution de la tache proprement dite, et la durée
qu'il possède pour l'exécuter.

\paragraph{}
Un système en mode batch, exécutant chaque tache d'un ensemble de taches $E_{\tau}$ l'une après l'autre sans intelligence,
doit respecter uniquement la règle suivante pour s'assurer que chaque tache est ordonnançable à temps :

$$\forall \tau_{i} \in E_{\tau}, B_{\tau} \textrm{ contenant toutes les taches précédantes à } \tau_{i}$$
$$T_{m}(\tau_{i}) > T_{e}(\tau_{i}) + \sum_{\tau_{b} \in B_{\tau}} T_{e}(\tau_{b})$$

Ainsi, lors de l'arrivée d'une nouvelle tache $\tau_{i}$, il est possible de définir son ordonnançabilité, et
au besoin de la refuser.

\paragraph{}
Les algorithmes en mode batch sont aujourd'hui révolus, du fait de leur manque d'optimisation de la gestion des taches.
Ainsi, là où un ordonnanceur intelligent pourrait, pour une nouvelle instance $\tau_{i}$ urgente, essayer de la
placer plus en aval dans sa liste tout en s'assurant du maintient de l'ordonnançabilité des autres taches, un ordonnanceur
en mode batch la refuserait.

\paragraph{}
La prise en compte de l'impact de l'exécution de chaque tache sur l'ordonnançabilité de toutes les autres est à la base
de la définition des ordonnanceurs temps réel. Il devient nécessaire, à partir de ce moment, de définir ce qu'est un
ensemble de taches.

\subsection{Définition des ensembles de taches}

\paragraph{}
Pour aborder la problématique temps réel, on définit un profil d'environnement logiciel, nommé ensemble de taches ({\it
\gls{taskset}}). Cet ensemble se définit comme suit :
\begin{itemize}
\item Une liste de taches $\tau$, chaque tache possédant un {\it WCET} et une {\it deadline} qui lui est propre
\item Chaque tache se matérialise sous la forme d'une {\it instance de tache}, correspondant à un processus logiciel.
\item Un profil d'arrivée des instances de tache (arrivée périodique, sporadique ou apériodique)
\end{itemize}

\paragraph{}
On parle alors de l'ordonnançabilité d'une tache, au travers de la capacité d'exécution de toutes ses instances.\\
Un ensemble de tache est nécessairement finit, et possède des caractéristiques fixes dans le temps.

\subsubsection{Les ensembles périodiques}

\paragraph{}
Les ensembles périodiques respectent la propriété suivante :\\
Chaque tache $\tau_{i}$ est instanciée à une période fixe $P_{i}$ connue.

\paragraph{}
Ainsi, en connaissant la date de la première instanciation d'une tache, on est capable de prédire les dates d'instanciation
de cette tache durant toute la durée de vie de l'ensemble de taches.

\paragraph{}
On peut de plus mesurer la charge maximum induite par cette tache, en s'appuyant sur $WCET(\tau_{i})$ et $P_{i}$. De
plus, la variation de la charge induite par cette tache dépend uniquement du de la variation du coût d'exécution de
chaque instance de $\tau_{i}$.

\subsubsection{Les ensembles sporadiques}

\paragraph{}
Les ensemble sporadiques respectent la propriété suivante :\\
Chaque tache $\tau_{i}$ est instanciées avec une période {\it minimum} $P_{i}$ définie.

\paragraph{}
On connaît donc la charge pire cas de chaque tache,  en s'appuyant sur $WCET(\tau_{i})$ et $P_{i}$.\\
Par contre, on ne peux pas prédire les dates d'instanciation successives de cette tache. De plus,
la variation de la charge induite par cette tache dépend à la fois du coût d'exécution effectif de
chaque instance de $\tau_{i}$ et de l'élongation de la période $P_{i}$.

\subsubsection{Les ensembles apériodiques}

\paragraph{}
Les ensembles apériodique respectent la propriété suivante :\\
Aucune tache n''est soumise à une période d'instanciation minimum. Une instance peut être créée n'importe quand,
indépendament de la finition de l'instance précédente.

\paragraph{}
On ne connaît pas la charge pire cas de chaque tache, la valeur de $P_{i}$ appartenant à l'ensemble $[0, +\infty[$

\subsubsection{Les ensembles fenêtrés}

Une fenêtre glissante de temps ${\Delta}t$ est définie, et on lui associe un nombre d'interruptions
maximum. Cette valeur est utilisée en entrée de la mesure du WCET.

\subsection{La dynamique des ensembles de taches}

\subsubsection{Les ensembles concrets}

\subsubsection{Les ensembles non concrets}

\section{Introduction à l'estimation du WCET}

\paragraph{}
La mesure du \gls{wcet} est complexe pour de multiples raisons. En effet, pour définir la charge processeur maximum nécessaire à
l'exécution d'une tache, il faut connaître l'ensemble des variables impactant le fonctionnement de celle-ci, tant en terme
d'algorithmique qu'en terme d'environnement logiciel et matériel.

\paragraph{}
En mesurant le coût d'exécution d'une tache indépendament des autres taches présentes sur le système, on rend cette
mesure plus accessible. En effet, définir l'environnement logiciel d'exécution est hasardeux, voire impossible lorsque la liste des
instances de taches présentes varie au fur et à mesure de l'exécution de l'ensemble de tache. C'est le cas dès que l'ensemble
de tache n'est pas périodique.

\paragraph{}
Cependant, en retirant l'impact de l'environnement logiciel d'exécution, on soustrait de la mesure du \gls{wcet} l'impact
des préemptions. Ainsi, même en considérant les caches désactivés, les évènements de sauvegarde de contexte processeur et
les évènements de {\it page miss} du TLB lié à l'exécution d'une autre tache ne sont pas pris en compte.\\
De la même manière, surtout dans le cas d'architectures avec caches désactivés, les accès mémoire fait par des éléments environnementaux
comme un processus sur un autre c{\oe}ur, un controlleur DMA ou encore le coût d'accès aux données en mémoire, dépendant
directement de la technologie employée au niveau matériel, ont un impact non négligeable sur le coût d'exécution d'une
tache.\\
Malheureusement, plus on considère les éléments matériels dans la mesure du \gls{wcet}, moins cette mesure est évolutive. En effet,
la mesure de \gls{wcet} devient alors spécifique au matériel employé, au profil évènemenciel utilisé (profil des évènements asyncrhones
comme les interruptions et les DMA), et implique en conséquence de maîtriser complètement la cible d'exécution matérielle, logicielle et
évènemencielle de la tache.

\paragraph{}
Il existe cependant un certain nombre de solutions pour mesurer le \gls{wcet} d'une tache. Ces solutions sont diverses, et
leur résultat plus ou moins précis.

\section{Méthodes statiques d'estimation du WCET}

\subsection{Analyse du flot d'exécution}

\paragraph{}
Un autre type de mesure correspond à l'étude du code assembleur d'une tache, afin d'en extraire un arbre d'exécution. La
branche la plus coûteuse de cet arbre correspondrait alors à la dynamique d'exécution du \gls{wcet}.

\paragraph{}
La difficulté devient alors de s'assurer que cette dynamique d'exécution est cohérente avec l'algorithmie de la tache et
correspond donc bien à un comportement dynamique possible. En effet, lorsque les branchement dépendent d'éléments environnementaux
de la tache, il devient difficile de différencier une branche d'exécution impossible d'une branche d'exécution envisageable.

\subsection{Utilisation d'une interprétation abstraite}

\subsection{Mesure avec simulation de l'architecture matérielle par variables symboliques}

Prise en compte des pipelines et des caches code. Cache de données non mesurés car trop complexe.

\section{Méthodes dynamiques d'estimation du WCET}

\subsection{Mesure empirique}

\paragraph{}
On peut construire un ensemble de mesures de l'exécution d'une tache, et considérer la mesure la plus élevée comme
le \gls{wcet}. Plus cet ensemble est généré à partir de comportements représentatifs du mode nominal d'exécution,
plus la valeur maximum mesurée est proche du véritable \gls{wcet}.

\paragraph{}
La difficulté consiste à définir un ensemble représentatif du comportement de la tache en terme de dynamique d'exécution
(branchements, consommation mémoire, lecture/écriture de donnée). Cette dynamique dépendant le plus souvent de données
d'entrée dont la maîtrise n'est pas toujours garantie, seule la définition d'un pannel représentatif des données d'entrée
peut permettre de fournir une valeur au plus proche du \gls{wcet}.

\paragraph{}
Là où les outils de tests unitaires en mode MC/DC permettent de définir une représentation exhaustive de tous les comportement
d'une fonction, un outil de mesure du \gls{wcet} s'appuiant sur une définition formelle de toutes les entrées possibles
d'une tache permettrait alors de garantir, en terme de chemin d'exécution, la traversée du chemin le plus long. Une telle définition
est malheureusement spécifique à chaque tache, est devient alors très coûteuse.

\subsection{Définition des jeux de test}

\section{Les éléments non estimés}

FIXME : à reconsidérer en fonction des éléments étudiés au dessus.
\paragraph{}
Ces deux manières de définir le \gls{wcet} nécessite ensuite l'évaluation des impacts du matériel (temps d'accès mémoire,
impacts de l'ordonnancement du bus, impacts d'un changement de c{\oe}ur, mise à jour du cache TLB, etc), ainsi que de
l'évaluation des impacts du logiciel (impact de la préemption sur le rechargement du contexte, coût d'exécution du système
d'exploitation, de l'ordonnanceur, des allocateurs mémoire, etc).

\paragraph{}
Afin de se rapprocher du véritable \gls{wcet}, ses mesures ajoutent un pourcentage de consommation des différents éléments
(logiciels et matériel), afin de prendre en compte ces divers éléments.\\



\section{Conclusion}

\paragraph{}
FIXME: difficultés de prise en compte des impacts matériels et environementaux sur la mesure du WCET

