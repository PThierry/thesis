%%
%%
%% hardware_impacts.tex for thesis in /doctorat/these/tex
%%
%% Made by Philippe THIERRY
%% Login   <Philippe THIERRYreseau-libre.net>
%%
%% Started on  Fri Mar 12 16:36:41 2010 Philippe THIERRY
%% Last update Mon Aug 30 17:00:21 2010 Philippe THIERRY

\chapter{A propos de l'état de l'art des solutions de virtualisation}
\doMinitoc

\paragraph{}
{\it Les solutions de virtualisation sont de bons candidats pour répondre au besoin
sécuritaire porté par le MILS (Multi-Independent Level of Security) et le MLS
(MultiLevel Security). Ces solutions, pour certaines d'entre elles,
fournissent une architecture logicielle compatible avec le principe de {\it
Separation Kernel} comme décrit il y a plus de 20 ans par John Rushby
\cite{rushby1989kernels}. Le but d'un Separation Kernel est d'assurer un
cloisonnement strict entre des environnements logiciels, tout en ayant les
propriétés nécessaires pour être intégré dans la TCB. Dans ce chapitre, je décris les différentes
solutions existantes candidates au principe de {\it Separation Kernel}.}

\section{Étude de la sécurité des solutions de virtualisation existantes}

\subsection{Étude de la solution Xen}

\subsubsection{Principe}
\paragraph{}
Xen \cite{barham2003xen} est un hyperviseur s'appuyant sur une architecture de type micro-noyau. Ce
dernier fournit les éléments de base pour la gestion et le déploiement des
machines virtuelles, sous le contrôle d'une machine virtuelle particulière
correspondant à un domaine d'administration, appelé dans le cas de Xen {\it
  dom0} \cite{fraser2004safe}.

\paragraph{}
Ce domaine possède des droits élargis sur l'interface de communication entre
l'hyperviseur et les machines virtuelles. Il est en effet apte à
créer, configurer, lancer, stopper ou détruire toute autre machine virtuelle,
dénommée dans le cadre de Xen {\it domU}, pour domaine Utilisateur.

\paragraph{}
Xen fournit une solution de virtualisation de niveau OS. Ainsi, chaque machine
virtuelle possède sont propre noyau. Celui-ci peut être géré de plusieurs
manières:
\begin{enumerate}
  \item Via de la paravirtualisation. Dans ce cas, le noyau du domaine
    utilisateur est modifié pour s'appuyer sur l'API de l'hyperviseur dès
    qu'il est nécessaire de faire un traitement nécessitant des droits
    d'administrateur sur la machine
  \item Via de la virtualisation matérielle. Dans ce cas, l'hyperviseur
    s'appuie sur les mécanismes de virtualisation matérielle tels que Intel-VT
    ou AMD-V pour gérer la ségrégation des accès aux périphériques et à la
    mémoire. Cela permet d'exécuter des noyaux virtualisés non modifiés, comme
    le noyau Windows.
\end{enumerate}

\subsubsection{Synthèse}

\paragraph{}
Xen est une solution de virtualisation proposant plusieurs éléments
intéressants en terme de cloisonnement. Il peut assurer un cloisonnement
strict de la mémoire entre les machines virtuelles. Il est également apte à
assurer une charge minimum garantie à chaque machine virtuelle pour un laps de
temps donné. C'est le mécanisme de type SEDF décrit dans
l'hyperviseur \cite{cherkasova2007comparison}\cite{govindan2007xen}.\\
Il ne permet cependant pas de définir des politiques d'ordonnancement strictes
type Time Division Multiplexing.


\paragraph{}
Les tâches des machines virtuelles sont exécutées et ordonnancées par le noyau
invité de chacune d'entre elle. L'hyperviseur n'a donc pas la visibilité sur
la charge ou la manière dont sont ordonnancées les tâches hébergées dans les
machines virtuelles. Cependant, il est apte à réagir aux événements matériels
asynchrones, en adaptant l'ordonnancement des machines virtuelles pour
limiter la latence de traitement. Cependant, un tel ordonnancement est
difficilement compatible de contraintes temps réel.

\paragraph{}
Parmi les solutions open-source connues de virtualisation ou de partitionnement,
l'hyperviseur Xen est celui ayant la plus petite empreinte mémoire, du fait de
son architecture de type micro-noyau. Cependant, parmi les micro-noyaux, il
reste très volumineux avec ses 250.000 lignes de codes, en comparaison avec
les micro-noyaux de la famille L4 \cite{klein2009sel4}, décrits dans la
Section \ref{subsec:l4} de ce chapitre.

\paragraph{}
La gestion du réseau dans la solution Xen s'appuie exclusivement sur la pile
réseau du domaine d'administration. Ainsi, la définition du réseau virtuel se
fait via l'usage de bridges dans ce domaine, générant un overhead non nul dans
le chemin de données réseau d'une machine virtuelle utilisateur.\\
Ainsi, lorsque deux machines virtuelles communiquent, l'ordonnancement du
domaine d'administration est nécessaire pour permettre au flux d'être reçu
de l'émetteur puis renvoyé vers le destinataire \cite{apparao2006characterization}.

\paragraph{}
D'un point de vue sécurité, le domaine d'administration est d'ailleurs un
élement dangereux car ayant des droits très étendus. La solution CubesOS, qui
a été maquettée sur l'hyperviseur Xen, s'appuie sur un mécanisme de
chiffrement/déchiffrement des données entre les machines virtuelles
utilisateur afin de limiter l'impact d'une corruption du domaine
d'administration. Les systèmes de fichiers des machines virtuelles
utilisateurs sont également chiffrés afin de limiter la capacité du domaine
d'administration à modifier son contenu.\\
L'usage d'un tel domaine permet de pouvoir simplifier la gestion de la
dynamicité des machines virtuelles, ainsi que l'interaction avec le matériel,
mais au dépend de la sécurité générale du système \cite{han2011verifying}. Il est donc d'usage de
sortir le domaine d'administration de l'architecture logique, le rendant
accessible exclusivement via une console locale d'administration.\\
Enfin, cette solution n'est à ce jour pas certifiable à coût raisonnable,
du fait de la volumétrie de l'hyperviseur en terme de lignes de code.

\subsubsection{Conclusion}

\paragraph{}
La solution Xen est intéressante pour ses propriétés de partitionnement
spacial strict. Cependant, elle net permet pas de manière aisé un
partitionnement temporel strict de type TDM. La restriction principale à son
usage est son manque de portabilité sur les architectures embarquées. A ce
jour, seules les architectures ARM et x86/x86\_64 sont supportées, ce qui pose
porblème dans les domaines de l'avionique et des télécoms, où l'architecture
PowerPC est prédominante.

\subsection{Étude de la solution QubesOS}

\subsubsection{Principe}

\paragraph{}
QubesOS \cite{rutkowska2010qubes} est une solution logicielle ciblant les postes de travail. Les
exigences initiales de la solution Qubes sont de pouvoir assurer la
confidentialité des données personnelles et professionnelles. Afin de pouvoir
répondre à ces exigences, QubesOS s'appuie sur une architecture comparimentée
exécutant de manière autonome des environnements
d'exécution pour chaque type de donnée \cite{gadaleta2012effectiveness}.\\
Les accès aux périphériques sont déportés dans un domaine de confiance afin de
limiter l'accès au matériel pour les environnements compartimentés.\\

\subsubsection{Synthèse}

\paragraph{}
La solution Qubes s'appuie sur l'hyperviseur Xen et un mécanisme d'aggrégation
de la sortie graphique afin de permettre un accès unifié aux applications des
différents domaines de confidentialité. De plus, elle intègre un
outillage complexe et des mécanismes de communicaton entre les compartiments
chiffrant les données émises. Cependant, la solution
complète QubesOS est lourde et cible exclusivement les postes de travail x86
récents. La solution n'est pas compatible avec les besoins de l'embarqué, mais le
principe de compartimentation et les mécanisme internes de chiffrement sont
intéressant pour le besoin de confidentialité des données.

\subsection{Étude de la solution LXC}

\subsubsection{Principe}

\paragraph{}
La solution LXC \cite{lxc_web} est une solution de virtualisation applicative. Elle s'appuie
donc sur un noyau Linux hôte pour ordonnancer les tâches des différents
compartiments, avec une gestion de la politique d'ordonnancement
potentiellement spécifique à chaque compartiment. 

\paragraph{}
Pour les solutions de virtualisation applicative, la capacité à respecter des
exigences temps réel dépend directement des propriétés de l'ordonnanceur de
l'hôte. Cependant, une tâche temps réel d'un compartiment sera ordonnancée en
concurrence avec les autres tâches temps réel du système, ce qui implique
de maîtriser l'ensemble des tâches du système pour pouvoir répondre au besoin
temps réel. La solution LXC couplée à une solution de type Linux-RT peut
permettre de répondre à des besoins temps réel souple tout en assurant le
cloisonnement des différentes tâches. Dans les noyaux Linux récents, il est
également possible de définir un certain nombre de propriétés intéressantes en
terme de temps réel et de sécurité:
\begin{itemize}
  \item L'affinité, spécifiant sur quel(s) coeur(s) processeur(s) le
    compartiment doit s'exécuter
  \item La charge associée aux tâches temps réel du compartiment, définissant
    la charge maximum que peuvent consommer ces dernières
  \item La charge associée aux tâches non temps réel du compartiment, avec les
    mêmes propriétés
  \item La mémoire physique allouée de manière stricte, assurant un
    cloisonnement spatial entre les compartiments
\end{itemize}
Ces différentes propriétés rendent la solution intéressante pour des besoins
de sécurité limités et des besoins de temps réel souple, mais la solution reste
incompatible avec les besoins de temps réel dur et de haut niveau de sécurité, de par
la présence d'un noyau Linux comme environnement d'exécution des compartiments.

\subsubsection{Synthèse}

\paragraph{}
La solution LXC est intéressante pour les besoins de maquettage, mais ne
permet pas de répondre à des exigences de type MILS, car cette solution est
incompatible avec les Propriétés \ref{pro:noncontournable}, \ref{pro:evaluable},
\ref{pro:validation} et \ref{pro:inviolable} exigées par les architectures
MILS.\\
Pour des besoins de temps réel souple, elle reste envisageable si les
exigences de réactivités sont faibles (supérieur à la milliseconde, comme je
le montre dans le Chapitre \ref{sec:passerelle_systronique}).

\subsection{Étude de la famille L4}
\label{subsec:l4}

\paragraph{}
L4 représente une famille de micro-noyaux qui partagent un certain nombre de
principe d'architecture. Le niveau de sécurité ou la compatibilité avec les
exigences temps réel varient selon la solution L4 choisie. Ces noyaux dérivent
du micro-noyau L4, créé par Jochen Liedtke \cite{liedtke1995micro}\cite{liedtke1996toward}.

\subsubsection{Principe}

\paragraph{}
La famille L4 est composée de différents micro-noyaux écrits en C++, comme
{\it Fiasco}, {\it Pistachio} ou encore {\it seL4} \cite{klein2009sel4}.
Fiasco est une solution qui n'a été porté que
sur architecture x86, limitant fortement son usage. Cependant, Pistachio a été
porté sur un grand nombre d'architectures, dont ARM, PowerPC ou MIPS. Seules
les architectures Sparc ne sont pas supportées à ce jour. Le micro-noyau seL4 cible la
sécurité, mais est limité à deux architectures matérielles: x86 et ARM.
SeL4 a fait vérifier formellement son API et sa gestion mémoire en
2009 \cite{klein2009sel4}.

\subsubsection{Synthèse}

\paragraph{}
Des différents micro-noyaux de la famille L4, seL4 est celui qui semble le
plus proche du besoin sécuritaire. Son faible volume de code (7500 lignes) et
ses premiers travaux en terme de preuve formelle font de lui un bon candidat
au besoin MILS. Malheureusement, ce dernier n'est porté que sur deux
architectures et ne propose à ce jour aucune considération des exigences temps
réel.

\subsection{Étude de la solution PikeOS}
\label{sec:pikeos}

\subsubsection{Principe}

L'hyperviseur PikeOS \cite{pike_kaiser2007evolution} est un micro-noyau avec des propriétés temps réel
(certifié DO-178B-DALB) dont l'architecture logicielle permet de gérer un
système de type MLS.
L'architecture de la solution PikeOS est séparable en trois couches
distinctes.
\begin{itemize}
\item Le micro-noyau: Ce dernier gère les accès mémoires le mapping des
périphériques (lignes d'interruption, espace mémoire d'entrée/sortie)
dans les différents compartiments et bien sûr l'ordonnancement.
\item Les compartiments: Ces derniers peuvent être des tâches certifiables
ordonnançable directement par le micro-noyau ou un système d'exploitation
complet, impliquant un ordonnancement de type hiérarchique, comme le décrit la
Figure \ref{fig:pikeos}
\item Le {\it System Software}: Il gère les canaux de communications entre les
compartiments, mais également les droits d'accès sur l'état de la
machine de la part des différents compartiments (capacité à être informé de
l'état des autres compartiments, de redémarrer le compartiment ou de redémarrer le système,
etc).
\end{itemize}

\begin{figure}
\label{fig:pikeos}
\input{figures/pikeos.tex}
\caption{Architecture logicielle de la solution PikeOS}
\end{figure}

\paragraph{}
PikeOS s'appuie sur deux principes:
\begin{itemize}
\item Le principe de compartimentation spatiale, définissant un espace de
mémoire allouée de manière stricte, associé à une politique d'accès aux
périphériques définie par configuration
\item Le principe de compartimentation temporelle, définissant une durée et
une période d'activation. Cette compartimentation permet d'assurer une charge
processeur et une réactivité minimum assurée pour la où les tâches exécutée(s)
dans le compartiment temporel.
\end{itemize}

\paragraph{}
La solution PikeOS permet de gérer les politiques d'ordonnancement de type
Rate Monotonic (RM) avec 255 niveaux de priorités. Il permet de plus de définir
une séparation temporelle de type TDM venant s'ajouter à la politique d'ordonnancement RM
initiale, afin de déterminer des fenêtres d'ordonnancement strictes et
périodiques.
\paragraph{}
En terme de séparation spatiale, PikeOS permet d'assurer une séparation
spatiale stricte en définissant une répartition des compartiments en mémoire
par configuration, et assure la ségrégation des accès aux périphériques via
la MMU pour les espaces mémoire d'entrée/sortie et au travers d'une gestion
fine du contrôleur d'interruption pour associer chaque ligne d'interruption à
un compartiment spatial donné. C'est par l'assignation d'une compartimentation
spatiale et temporelle à chaque entité devant être ordonnancée que la
solution PikeOS permet à la fois de supporter des exigences en terme de temps réel
et de sécurité.

\subsubsection{Synthèse}

\paragraph{}
La capacité à ordonnancer à la fois des OS complexes et des tâches
certifiables fait de cette solution logicielle un bon candidat à l'intégration
des moniteurs de sécurité tels que nécessités par une architecture de type MLS
ou MILS \cite{pike_baumann2009verifying}.

\section{Synthèse}

\paragraph{}
L'usage d'une solution logicielle de virtualisation à faible empreinte mémoire
est un bon candidat au besoin MILS et MLS. Une telle solution permet ainsi
d'exécuter divers environnements dont les niveaux de sécurité et de sureté de
fonctionnement peuvent être hétérogènes. Cependant, cela implique une
compatibilité de la solution de virtualisation logicielle avec à la fois des
exigences de temps réel et de sécurité. Il est de plus nécessaire, afin de
permettre l'intégration de sécurité, d'avoir la possibilité de faire
s'exécuter sur l'hyperviseurs d'autres éléments logiciels que des systèmes
virtualisés. Ainsi, l'hyperviseur doit non seulement permettre l'exécution de
systèmes d'exploitations virtualisés, mais également des threads directement
ordonnancés par ce dernier, tout en assurant une compartimentation spatiale et
temporelle forte.\\
Parmi les différentes solutions de virtualisation étudiées, seule la solution
PikeOS de Sysgo permet de répondre à l'ensemble de ces besoins. C'est cette
solution que je considère dans ma thèse afin de répondre à la problématique
d'architecture de sécurité pour répondre à la fois aux exigences temps réel et
de sécurité.
