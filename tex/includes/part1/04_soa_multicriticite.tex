%%
%%
%% hardware_impacts.tex for thesis in /doctorat/these/tex
%%
%% Made by Philippe THIERRY
%% Login   <Philippe THIERRYreseau-libre.net>
%%
%% Started on  Fri Mar 12 16:36:41 2010 Philippe THIERRY
%% Last update Mon Aug 30 17:00:21 2010 Philippe THIERRY

\chapter{L'ordonnancement hiérarchique de tâches}
\label{sec:hierarchique}
\doMinitoc

\paragraph{}
{\it Afin de répondre au besoin des architectures MILS et MLS, l'usage d'un
separation kernel est une des solutions logicielles proposée. Cette
architecture, impliquant potentiellement la virtualisation de certaines
tâches, induit un ordonnancement hiérarchique de ces dernières. Dans ce
chapitre est décrit l'état de l'art de l'ordonnancement hiérarchique.}

\section{Principe de l'ordonnancement hiérarchique}

\subsection{Principes généraux et théorie de l'ordonnancement hiérarchique}

\paragraph{}
On parle d'ordonnancement hiérarchique lorsqu'une tâche est ordonnancée au
travers de deux politiques d'ordonnancement distinctes hiérarchisées. Dans les
systèmes temps réels, on considère alors un ensemble de jeux $\Gamma_i$ de
tâches exécutés en concurrence. Pour chaque jeux de tâches, on considère un ensemble de tâches
$\tau^i_j$ qui lui sont associées. On définit alors
\begin{enumerate}
\item Une politique d'ordonnancement des jeux de tâches, nommé ordonnancement
global
\item Une politique d'ordonnancement des tâches dans un jeu donné, nommé
ordonnancement local
\end{enumerate}

\paragraph{}
L'ordonnancement hiérarchique a été beaucoup étudié ces dernières années. La
capacité à ordonnancer de manière concurrente des jeux de tâches sur un même
c{\oe}ur processeur permet de pouvoir prendre en considération des classes de
tâches et différencier leur ordonnancement en fonction de leur profil. Ces
différents travaux ont pour hypothèse une connaissance initiale de l'ensemble
des tâches, hypothèse d'entrée exigée dans les systèmes temps réels
dur\cite{methodhierarchical}. 

\paragraph{}
La répartition des tâches par familles se fait en fonction des exigences de
réactivité. La Figure \ref{fig:hierarchical_sample} décrit une répartition
classique telle que décrite dans \cite{methodhierarchical}.

\begin{figure}
\label{fig:hierarchical_sample}
\input{figures/hierarchical_sample.tex}
\caption{Répartition type des tâches par jeux autonomes, en fonctions des exigences de réactivité}
\end{figure}

%\paragraph{}
%Analyse de concurrence des systèmes temps réels à ordonnancement hierarchique
%\cite{regehr_evolving_2003}\\
%Calcul du temps de réponse sur un système temps réel à ordonnancement
%hierarchique sur base de priorité fixe
%\cite{balbastre_exact_2009}\\
%Ordonnancement hiérarchique SMP
%\cite{chandra_hierarchical_2008}\\
%Le rôle de la virtualisation dont les systèmes embarqués
%\cite{heiser_role_2008}


\subsection{Ordonnancement hiérarchique et principe de virtualisation}

\paragraph{}
Lorsque la hiérarchisation de
l'ordonnancement provient du principe de virtualisation, les deux politiques
d'ordonnancement s'ignorent souvent l'une l'autre. En conséquence, les ordonnanceurs
en-ligne ne sont plus éligibles pour l'ordonnancement global, faute d'information sur la politique
d'ordonnancement intérieur à chaque ensemble de tâches. Ce dernier est donc en
général de type FP (Fixed Priority). Ce type de restriction est décrit dans
\cite{cucinotta_respecting_2009} où les auteurs expliquent l'impact de
l'ordonnanceur global sur la capacité des tâches virtualisées à rester
ordonnançable. Différents travaux \cite{cucinotta_respecting_2009}\cite{rtvm} ont été
fait sur la base de solution open-source comme Xen\cite{barham2003xen} ou
KVM\cite{kivity2007kvm}.

\paragraph{}
Du fait de la hiérarchisation de l'ordonnancement des tâches, on parle alors
de d'un ordonnancement de type X/Y, ou X spécifie l'ordonnancement des
machines virtuelles $\Gamma_i, i \in { a, b, c ... }$, Y définissant
l'ordonnancement des tâches $\tau^i_j$ de la machines virtuelle $\Gamma_i$.\\
Un exemple d'ordonnancement hiérarchique est l'EDF/RM, où les tâches sont
ordonnancées suivant une politique de type EDF et les jeux de tâches des
différentes machines virtuelles sont ordonnancés suivant une politique de type RM.
Les calculs d'ordonnançabilité sont impactés par le principe de hiérarchie, et nécessitent donc
d'être considérés de manière spécifique.

\paragraph{}
Du fait de la hiérarchisation de l'ordonnancement des tâches, on parle alors
de d'un ordonnancement de type X/Y, ou X spécifie l'ordonnancement des
machines virtuelles $\Gamma_i, i \in { a, b, c ... }$, Y définissant
l'ordonnancement des tâches $\tau^i_j$ de la machines virtuelle $\Gamma_i$.\\
Un exemple d'ordonnancement hiérarchique est l'EDF/RM, où les tâches sont
ordonnancées suivant une politique de type EDF et les jeux de tâches des
différentes machines virtuelles sont ordonnancés suivant une politique de type RM.
Les calculs d'ordonnançabilité sont impactés par le principe de hiérarchie, et nécessitent donc
d'être considérés de manière spécifique.


\paragraph{}
Dans la solution Xen, une implémentation de S-EDF a été faite afin d'assurer
une réservation de ressource CPU minimum dans une fenêtre temporelle aux
différentes machines virtuelles. Cependant, cette solution a ses limitations,
principalement lorsque les tâches temps réelles impliques un grand nombre
d'entrées/sorties, impactant le respect de l'ordonnancement des autres
machines virtuelles\cite{cucinotta_respecting_2009}.\\
KVM utilise une architecture différente, puisqu'il implique un hôte pouvant
ordonnancer des tâches potentiellement temps réel à côté de machines
virtuelles. Dans ce cas, les tâches natives (non virtualisées) impactent
potentiellement fortement l'ordonnancement des machines virtuelles et des jeux
de tâches associés, comme le décrivent T. Cucinotta, g. Anastasi et L. Abeni
dans \cite{rtvm}. L'emploi d'un ordonnanceur de type CBS (Constant Bandwidth Server\cite{abeni1998integrating})
permet d'assurer une réservation stricte de charge processeur pour les
différentes machines virtuelles, limitant fortement l'impact des tâches
natives. La gestion concurrentes de jeux de tâches temps réels virtualisé et
de jeux de tâches natifs (ordonnancés directement par l'hôte) est donc un
problème complexe à résoudre. Dans le cadre des architectures MILS, ce type
d'architecture est malheureusement nécessaire afin de pouvoir traiter les
moniteurs de sécurité comme des tâches du {\it separation kernel}, ces
dernières ne pouvant être intégrés à un OS virtualisés sans perdre leur
certifiabilité.

%saewong2002analysis

%\section{A propos de l'ordonnancement hiérarchique sur base TDM}
%\paragraph{}
%a considération d'un ordonnancement de jeu de tâche de type TDM est un cas
%ntéressant d'ordonnancement hiérarchique. Les jeux de tâches sont ordonnancés
%e manière stricte via la définition d'un motif répétitif d'ordonnancement. La
%olitique d'ordonnancement des tâches doit donc considérer deux propriétés:
%begin{itemize}
%item La charge processeur allouée au compartiment, impactant la capacité à
%rdonnancer les tâches en terme de charge
%item La période d'élection du compartiment, impactant la capacité à respecter
%es deadlines des tâches
%end{itemize}

%paragraph{}
%'ai étudié cette problématique d'ordonnançabilité afin de valider le fait
%ue plusieurs ensembles de tâches ordonnancés en TDM restaient certifiables en terme
%'ordonnançabilité.


\chapter{A propos de l'état de l'art de l'ordonnancement de tâche à criticité mixte}
\doMinitoc

\section{Principe de la criticité mixte}

\subsection{Propriété des tâches d'un ensemble à criticité mixte}

\paragraph{}
En 2007, S. Vestal\cite{vestal2007preemptive} a décrit le principe d'une tâche
dont la criticité peut être mixte. On définit une tâche à criticité
mixte en définissant
plusieurs pire cas d'exécution (WCET), chaque WCET étant associé à un niveau
de criticité. La multiplicité des coûts d'exécution pire cas viens du niveau
d'assurance exigé par chaque niveau de criticité. Plus ce dernier est élevé,
plus l'assurance demandée par la certification est forte. En conséquence, la
mesure d'exécution pire cas est de plus en plus pessimiste afin de garantir
que la tâche respecte son WCET. Ainsi, une tâche de faible niveau de criticité
peut s'appuyer sur une mesure probabiliste, dont le WCET est forcément plus
faible qu'une mesure formelle du profil d'exécution d'une tâche.

\paragraph{}
On définit pour chaque tâche de l'ensemble de tâches un niveau de criticité en
fonction de son importance. Un système s'exécute par défaut dans le domaine de
criticité le plus faible. Si une tâche de criticité supérieure au domaine
courant dépasse le WCET qui lui est donné pour ce domaine, on
considère qu'il faut changer de domaine de criticité. On accroît alors le
domaine de criticité du système et on désactive les tâches dont le niveau de
criticité est inférieur au nouveau domaine de criticité actif. Ceci est fait afin de
maintenir l'ordonançabilité des tâches critiques, ces dernières ayant alors un
WCET plus élevé, correspondant à celui du domaine de criticité nouvellement
actif.

%To insert: \cite{handlemulticrit}

\subsection{A propos De l'ordonnancement d'un ensemble de taches à criticité mixte}

\paragraph{}
L'ordonnancement à criticité mixte est un domaine de recherche émergeant
gagnant un intérêt croissant. Vestal \cite{Vestal2007} a initialement
introduit le modèle de tache à criticité mixte. Dans son travail, il décrivit
la difficulté à calculer le coût d'exécution pire cas exact, et observa que
dans la pratique, plus le niveau d'assurance requis est élevé, plus pessimiste
était l'approximation de la valeur du coût d'exécution pire cas. Ce niveau
d'assurance est caractérisé par le niveau de criticité. Il suggéra également
une stratégie basée sur l'ordonnancement à priorité fixe basée sur
le principe d'assignement de priorité de Audsley \cite{Audsley_1991}. Dorin et
al. \cite{Dorin2010} ont prouvé que dans le cas restreint des systèmes à
taches indépendantes à deadline contraintes, l'approche modifié du principe
d'Audsley par Vestal était optimale pour les algorithmes de priorisation
d'ensembles de taches à criticité mixte.
Aujourd'hui, la problématique de criticité mixe (MC-ordonnançabilité) est
communément connue pour arriver dans deux contextes différents.
Le premier correspond à des exigences de certifications multiples. Dans ce
contexte, différentes autorités de certification ont besoin de valider les
fonctionnalités de l'application. Néanmoins, plus la fonctionnalité est
critique, plus pessimiste sera l'approximation du WCET. Baruah et al. \cite{Baruah2010}
ont étudié les systèmes à criticité mixte dans ce contexte, mais ont restreint
leur travail à un ensemble de jobs à criticité mixte. En particulier, Baruah
\cite{bbalmms} a montré l'intraitabilité du MC-ordonnançabilité. Ils ont alors
suggéré deux conditions d'ordonnançabilité suffisantes, dénotés
condition de WCR-ordonnançabilité et condition d'OCBP-ordonnançabilité.
Plus tard, Baruah et Li \cite{Li2010} ont étendu leur travaux initiaux et
proposère une stratégie d'ordonnancement à priorité fixe basée sur la
condition d'OCBP-ordonnançabilité. Barual et al. ont également adapté
l'algorithme EDF (Earliest Deadline First) pour les ensemble de taches à
criticité mixte. Cette approche est connue sous le nom EDF-VD. Plus récement,
Quan et al. \cite{gpmw} ont présenté une nouvelle approche pour ordonnancer
des systèmes à criticité mixte, qui s'appuie sur un calcul hors ligne de la
priorité des jobs, qui est ensuite utilisée par un ordonnanceur en ligne. Au
même moment, Baruah et al. \cite{RBaruah2011a} formalisèrent l'analyse de
temps de réponse de taches à criticité mixte.\\
Le second contexte dans lequel la criticité mixte est définie considère que
parmis toutes les fonctionnalités déployées sur une unique plateforme de
calcul, certaines peuvent être plus critiques que d'autre en terme
d'importance pour le bon fonctionnement général de la solution. C'est le cas
dans le cadre de la définition d'une passerelle d'interconnexion Systronique.
Ainsi, certains traitement de flux sont plus critiques, comme le traitement
du système d'arme que d'autres, comme les caméras extérieures. Dans ce
contexte, Lakshmanan et al. \cite{Niz2009,Lakshmanan2011} ont observé que
l'approche basée sur la réservation afin d'isoler les fonctionnalités et
prévenir les interférences, peuvent avoir pour conséquence un problème
d'inversion de criticité, où une tache moins critique est favorisée par
rapport à une tache de plus haute criticité lorsque cette dernière dépasse
le slot temporel lui ayant été alloué. Ils suggérèrent une nouvelle approche,
dénommée {\it zero-slack scheduling}, pour éviter ce problème. Dans le cas de
la passerelle Systronique, la découpe entre tache est maintenue en TDM pour
des raisons de sécurité, afin d'empêcher l'usage d'un canal caché basé sur la
variation de durée du slot afin de transmettre de l'information aux autres
slot au travers l'impact de cette variation.



