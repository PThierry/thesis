%%
%%
%% 01_definition_modele.tex for thesis in /doctorat/these/tex
%%
%% Made by Philippe THIERRY
%% Login   <Philippe THIERRYreseau-libre.net>
%%
%% Started on  Tue Aug 31 13:12:11 2010 Philippe THIERRY
%% Last update Tue Jul  5 11:14:04 2011 Philippe THIERRY
%%

\chapter{Security and afety requirements which should be respected}

\section{Macroscopic security requirements}

\paragraph{}
\begin{itemize}
\item From a given operating virtual machine, it should not be possible to read data from another virtual
machine
\item From a given operating virtual machine, it should not be possible to write data into another
virtual machine
\item From a given operating virtual machine, it should not be possible to impact the behaviour of
another virtual machine
\end{itemize}

\section{Macroscopic security requirements}

\paragraph{}
\begin{itemize}
\item If the behaviour of a given virtual machine varies abnormally, it should be detected by a
behaviour controller
\item A behaviour controller should be able to log any behaviour variation to a system logging
facility
\item The behaviour controller should be able to react to a behaviour variation depending on the
associated safety policy (stop/reboot/...)
\item Whatever the behaviour of a given virtual machine is, it should not impact the other executed
virtual machines
\end{itemize}



\chapter{Formalization of the real-time problematic for I/O flow management}

\section{Formal requirements on the hardware  behaviour}

\section{Formal requirements on the software behaviour}

\section{Toward a first compliant formal implementation model}

\subsection{Defining a flow management taskset}

\subsection{About I/O unpredictability}

\chapter{Defining and formalizing security elements}

\section{On the definition of the integrated security subsystems}

\subsection{Software security systems}

\subsection{Hardware security systems}

\section{About the real-time and security system formal requirements}

\subsection{Incompatibilities}

\subsection{Defining a valid set}



%\section{On the input requirements on software and hardware architecture}

%\section{Through a first macroscopic model of software architecture}

%\subsection{Introduction}

%\subsubsection{On hardware properties}

%\begin{enumerate}
%\item Le matériel doit fournir au logiciel deux niveaux de privilèges
%\item Seul le logiciel s'exécutant avec le niveau de privilèges  le  plus  élevé  peux  modifier  le
%niveau de privilège dans lequel il s'exécute
%\item Seul le logiciel s'exécutant dans le niveau de privilèges  le  plus  élevé  peut  définir  les
%politiques  d'accès  au  matériel   pour   les   différents   logiciels   des   niveaux   supérieurs
%\item Le matériel doit fournir un mécanisme  de  cloisonnement  mémoire  des  différents  logiciels.
%\item Seul le logiciel s'exécutant dans le niveau  de  privilège  le  plus  élevé  peut  définir  et
%modifier se cloisonnement
%\end{enumerate}
%
%\subsubsection{On software properties}
%
%Cette  partie  se  concentre  sur  la  définition  d'un  premier  modèle  de  solution   logicielle.
%
%\begin{enumerate}
%\item Le logiciel se définit  comme  une  association  entre  une  base  fournissant  une  interface
%d'abstraction du matériel, et un ensemble de logiciels ayant une  tache  unique  et  indépendante  à
%exécuter.
%\item On définit le logiciel de base sous le nom noyau
%\item Le noyau est le  seul  logiciel  s'exécutant  dans  le  niveau  de  privilège  le  plus  élevé
%\item   Le   noyau   définit   les   politiques   d'accès   au   matériel   des   autres   logiciels
%\item Seul le noyau peut définir ces politiques d'accès
%\item Le noyau  n'apporte  aucune  valeur  ajoutée  autre  que  la  capacité  de  gérer  les  autres
%logiciels et leur politique d'accès au matériel
%\item  Le  noyau   interfère   le   moins   possible   dans   l'exécution   des   autres   logiciels
%\item Le noyau garantie un ordonnancement des autres logiciels
%\item L'ordonnancement des autres logiciels permet le respect des hypothèses nécessaires au temps réel dur
%\item Le noyau doit fournir une interface aux autres logiciels indépendante du matériel  sous-jacent
%\item On définit une communication entre logiciel comme la  capacité  d'un  logiciel  à  initier  un
%traitement   spécifique    dans    un    autre    logiciel    (e.g.,    IPC,    appel    via    API)
%\item Les autres logiciels ne peuvent communiquer avec le  noyau  qu'au  travers  de  l'API  que  ce
%dernier leur fournit
%\end{enumerate}
%
%\section{Defining a first mathematical model of the software architecture}
%
%\paragraph{}
%On définit en premier lieu une instance de noyau, nommé $k_{i}$, appartenant à l'ensemble $K_{n}$ (où
%$n$ est le cardinal de l'ensemble) des noyaux pouvant être  générés  à  partir  de  sources  $S_{k}$
%associées à l'ensemble $K_{n}$.
%
%Les éléments $k_{i}$ de l'ensemble $K_{n}$  doivent  respecter  un  certain  nombre  de  propriétés.
%
%Soit $U_{m}$ un ensemble de logiciels de cardinal $m$. Cet ensemble possède les propriétés
%suivantes:
%\begin{itemize}
%\item Pour tout logiciel $u_{i} \in U_{n}$ le schéma d'exécution est le même (périodique,
%apériodique ou sporadique).
%\end{itemize}
